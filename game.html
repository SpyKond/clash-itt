<!DOCTYPE html>
<html lang="ru">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
Â  Â  <title>Clash Of IT - Battle</title>
Â  Â  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
Â  Â  <style>
Â  Â  Â  Â  body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; color: white; user-select: none; touch-action: none; display: flex; flex-direction: column; height: 100vh; }
Â  Â  Â  Â  #game-ui { flex-grow: 1; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; }
Â  Â  Â  Â  #canvas-wrapper { position: relative; width: 100%; display: flex; justify-content: center; }
Â  Â  Â  Â  canvas { background: #111; border: 3px solid #333; display: block; }
Â  Â  Â  Â  #top-bar { height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px; color: #00fbff; background: #111; border-bottom: 2px solid #333; width: 100%; font-weight: bold; }
Â  Â  Â  Â  #build-ui { position: absolute; bottom: 10px; display: none; gap: 5px; background: rgba(0,0,0,0.9); padding: 8px; border-radius: 12px; align-items: center; border: 1px solid #444; z-index: 50; flex-wrap: wrap; justify-content: center; width: 90%; }
Â  Â  Â  Â  #controls-wrapper { min-height: 180px; background: #121212; display: none; flex-direction: column; align-items: center; gap: 8px; padding: 12px 5px; border-top: 3px solid #333; width: 100%; box-sizing: border-box; }
Â  Â  Â  Â  #elixir-row { display: flex; gap: 4px; margin-bottom: 5px; }
Â  Â  Â  Â  .elixir-cell { width: 22px; height: 14px; background: #222; border: 1px solid #000; border-radius: 2px; position: relative; overflow: hidden; }
Â  Â  Â  Â  .elixir-fill-inner { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: #e040fb; box-shadow: 0 0 10px #e040fb; }
Â  Â  Â  Â  #hand-container { display: flex; gap: 8px; justify-content: center; width: 100%; max-width: 500px; }
Â  Â  Â  Â  .card { width: 75px; height: 110px; background: linear-gradient(145deg, #333, #222); border: 3px solid #555; border-radius: 10px; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; text-align: center; color: #fff; transition: transform 0.1s; }
Â  Â  Â  Â  .card .cost { position: absolute; top: -8px; left: -8px; background: #e040fb; border-radius: 50%; width: 24px; height: 24px; line-height: 24px; border: 2px solid white; font-size: 14px; z-index: 10; font-weight: bold; }
Â  Â  Â  Â  .card .rating-tag { position: absolute; top: 2px; right: 4px; font-size: 10px; font-weight: bold; }
Â  Â  Â  Â  .card b { font-size: 10px; text-transform: uppercase; margin-top: 5px; }
Â  Â  Â  Â  .card-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.75); z-index: 5; pointer-events: none; border-radius: 7px; }
Â  Â  Â  Â  #countdown { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; font-size: 80px; background: rgba(0,0,0,0.5); z-index: 2000; color: #00fbff; font-weight: bold; }
Â  Â  Â  Â  #game-msg-box { position: fixed; inset: 0; display: none; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.95); z-index: 9999; }
Â  Â  Â  Â  .btn { padding: 8px 10px; border: none; border-radius: 5px; color: white; font-weight: bold; cursor: pointer; font-size: 9px; text-transform: uppercase; }

Â  Â  Â  Â  /* Ğ¡Ñ‚Ğ¸Ğ»Ğ¸ Ğ»Ğ¾Ğ±Ğ±Ğ¸ */
Â  Â  Â  Â  #lobby-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; justify-content: center; align-items: center; }
Â  Â  Â  Â  .lobby-window { background: #222; padding: 25px; border: 2px solid #444; border-radius: 15px; text-align: center; width: 300px; }
Â  Â  Â  Â  .id-box { background: #000; padding: 10px; margin: 10px 0; font-family: monospace; color: #00fbff; border: 1px dashed #555; cursor: pointer; }
Â  Â  Â  Â  .lobby-status { margin: 15px 0; font-size: 14px; }
Â  Â  </style>
</head>
<body>

<div id="lobby-overlay">
Â  Â  <div id="lobby-choice" class="lobby-window">
Â  Â  Â  Â  <h2>Ğ’Ğ«Ğ‘Ğ•Ğ Ğ˜Ğ¢Ğ• Ğ Ğ•Ğ–Ğ˜Ğœ</h2>
Â  Â  Â  Â  <button class="btn" style="background:#4CAF50; padding:15px; width:100%; margin-bottom:10px;" onclick="startBotMode()">ĞŸĞ ĞĞ¢Ğ˜Ğ’ Ğ‘ĞĞ¢Ğ</button>
Â  Â  Â  Â  <button class="btn" style="background:#2196F3; padding:15px; width:100%;" onclick="openLobbyMenu()">Ğ›ĞĞ‘Ğ‘Ğ˜ 1 ĞĞ 1</button>
Â  Â  </div>

Â  Â  <div id="lobby-main" class="lobby-window" style="display:none;">
Â  Â  Â  Â  <h3>Ğ’ĞĞ¨ ID:</h3>
Â  Â  Â  Â  <div class="id-box" id="my-id-display" onclick="copyID()">Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°...</div>
Â  Â  Â  Â  <input type="text" id="friend-id-input" placeholder="ID Ğ”Ğ Ğ£Ğ“Ğ" style="width:90%; padding:10px; margin-bottom:10px; background:#111; color:white; border:1px solid #555;">
Â  Â  Â  Â  <button class="btn" style="background:#2196F3; width:100%;" onclick="connectToFriend()">Ğ—ĞĞ™Ğ¢Ğ˜ Ğš Ğ”Ğ Ğ£Ğ“Ğ£</button>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div id="lobby-wait" style="display:none;">
Â  Â  Â  Â  Â  Â  <div class="lobby-status">Ğ’Ğ«: <span id="p1-status" style="color:red">ğŸ”´</span></div>
Â  Â  Â  Â  Â  Â  <div class="lobby-status">Ğ”Ğ Ğ£Ğ“: <span id="p2-status" style="color:red">ğŸ”´</span></div>
Â  Â  Â  Â  Â  Â  <button id="ready-btn" class="btn" style="background:#4CAF50; width:100%; height:40px;" onclick="toggleReady()">Ğ“ĞĞ¢ĞĞ’</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
</div>

<div id="top-bar">03:00</div>
<div id="game-ui">
Â  Â  <div id="canvas-wrapper">
Â  Â  Â  Â  <canvas id="canvas"></canvas>
Â  Â  Â  Â  <div id="build-ui">
Â  Â  Â  Â  Â  Â  <div id="wall-dock" style="width:35px; height:15px; background:#888; border:2px solid #fff; border-radius:2px;" onpointerdown="startWallDrag()"></div>
Â  Â  Â  Â  Â  Â  <span style="font-size: 10px; font-weight: bold;">Ğ¡Ğ¢Ğ•ĞĞ«: <span id="wall-rem">7</span></span>
Â  Â  Â  Â  Â  Â  <button class="btn" style="background:#2196F3" onclick="handleRotate()">ĞŸĞĞ’Ğ•Ğ ĞĞ£Ğ¢Ğ¬</button>
Â  Â  Â  Â  Â  Â  <button class="btn" style="background:#ff9800" onclick="randomPlayerWalls()">Ğ ĞĞĞ”ĞĞœ</button>
Â  Â  Â  Â  Â  Â  <button class="btn" style="background:#f44336" onclick="deleteAllWalls()">X</button>
Â  Â  Â  Â  Â  Â  <button class="btn" style="background:#4CAF50" onclick="confirmReady()">Ğ“ĞĞ¢ĞĞ’Ğ</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
</div>
<div id="controls-wrapper">
Â  Â  <div style="font-size: 14px; color: #e040fb; margin-bottom: 2px; font-weight: bold;">Ğ­Ğ›Ğ˜ĞšĞ¡Ğ˜Ğ : <span id="elixir-val">0</span></div>
Â  Â  <div id="elixir-row"></div>
Â  Â  <div id="hand-container"></div>
</div>
<div id="countdown">3</div>
<div id="game-msg-box">
Â  Â  <div id="game-msg-text" style="font-size: 40px; color: #ffeb3b; margin-bottom: 20px;"></div>
Â  Â  <button class="btn" style="background:#2196F3; padding:15px 40px; font-size:20px; border-radius:10px;" onclick="location.href='index.html'">Ğ’ ĞœĞ•ĞĞ®</button>
</div>

<script src="assets.js"></script>

<script>
// --- ĞŸĞ•Ğ Ğ•ĞœĞ•ĞĞĞ«Ğ• Ğ¡Ğ•Ğ¢Ğ˜ ---
let peer = new Peer();
let conn = null;
let isLobbyMode = false;
let amIReady = false;
let isFriendReady = false;
let isHost = false;

peer.on('open', id => document.getElementById('my-id-display').innerText = id);
peer.on('connection', c => { conn = c; isHost = true; setupConn(); document.getElementById('lobby-wait').style.display='block'; });

function openLobbyMenu() { document.getElementById('lobby-choice').style.display='none'; document.getElementById('lobby-main').style.display='block'; }
function copyID() { navigator.clipboard.writeText(document.getElementById('my-id-display').innerText); alert("ID Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½!"); }
function connectToFriend() {
Â  Â  let fid = document.getElementById('friend-id-input').value;
Â  Â  if(!fid) return;
Â  Â  conn = peer.connect(fid); isHost = false; setupConn(); document.getElementById('lobby-wait').style.display='block';
}

function setupConn() {
Â  Â  conn.on('data', data => {
Â  Â  Â  Â  if(data.type === 'ready') { isFriendReady = data.val; updateLobbyUI(); checkLobbyStart(); }
Â  Â  Â  Â  if(data.type === 'spawn') { spawnUnit(CLASS_STATS[data.key.toLowerCase()], BW - data.x, BH - data.y, 'enemy'); }
Â  Â  });
}

function toggleReady() { amIReady = !amIReady; conn.send({type:'ready', val: amIReady}); updateLobbyUI(); checkLobbyStart(); }
function updateLobbyUI() {
Â  Â  document.getElementById('p1-status').innerText = amIReady ? "ğŸŸ¢" : "ğŸ”´";
Â  Â  document.getElementById('p2-status').innerText = isFriendReady ? "ğŸŸ¢" : "ğŸ”´";
}
function checkLobbyStart() { if(amIReady && isFriendReady) { isLobbyMode = true; document.getElementById('lobby-overlay').style.display='none'; startGame(); } }
function startBotMode() { isLobbyMode = false; document.getElementById('lobby-overlay').style.display='none'; startGame(); }

// --- Ğ¢Ğ’ĞĞ™ ĞĞ Ğ˜Ğ“Ğ˜ĞĞĞ›Ğ¬ĞĞ«Ğ™ ĞšĞĞ” Ğ“Ğ•Ğ™ĞœĞŸĞ›Ğ•Ğ¯ ---
const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
const BW = 500, BH = 900, ROWS = 16, COLS = 8, cellW = BW / COLS, cellH = BH / ROWS;

let gameActive = false, isBuilding = false, gameOverTriggered = false;
let elixir = 0, enemyElixir = 0, battleTime = 180, scale = 1, eRate = 0.0075, dpr = window.devicePixelRatio || 1;
let units = [], towers = [], walls = [], hand = [], fx = [];
let draggingWallIdx = null, draggingCardIdx = null, fromDock = false, wallRotated = false, wallsLeft = 7;
let lastTouchPos = { x: 0, y: 0, active: false }, lastEnemySpawn = 0;

const CLASS_STATS = {
Â  Â  'Ñ‚Ğ°Ğ½Ğº': { cost: 5, hp: 1300, damage: 160, speed: 0.5, size: 22, range: 45, color: '#444', canAttackAir: false, isTank: true },
Â  Â  'Ğ»ÑƒÑ‡Ğ½Ğ¸Ğº': { cost: 3, hp: 180, damage: 30, speed: 0.9, size: 12, range: 180, color: '#e91e63', canAttackAir: true },
Â  Â  'Ğ±Ğ»Ğ¸Ğ¶Ğ½Ğ¸Ğº': { cost: 2, hp: 350, damage: 35, speed: 1.3, size: 14, range: 45, color: '#ff9800', canAttackAir: false },
Â  Â  'Ğ°Ñ€Ğ¼Ğ¸Ñ': { cost: 3, hp: 50, damage: 12, speed: 1.4, size: 8, range: 35, isSwarm: true, count: 4, color: '#795548', canAttackAir: false },
Â  Â  'Ğ»ĞµÑ‚ÑƒĞ½': { cost: 4, hp: 160, damage: 40, speed: 0.8, size: 14, range: 170, color: '#00fbff', isAir: true, atkSpeed: 1400, canAttackAir: true },
Â  Â  'Ñ€Ğ¾Ğ¹': { cost: 5, hp: 80, damage: 18, speed: 1.0, size: 9, range: 150, isSwarm: true, count: 3, color: '#03a9f4', isAir: true, atkSpeed: 1100, canAttackAir: true },
Â  Â  'Ğ¼ĞµĞ´Ğ¸Ğº': { cost: 4, hp: 220, damage: 0, speed: 1.0, size: 13, range: 150, isHealer: true, color: '#4caf50', canAttackAir: false },
Â  Â  'Ñ‚ÑƒÑ€ĞµĞ»ÑŒ': { cost: 6, hp: 500, damage: 45, speed: 0, size: 20, range: 220, isBuilding: true, color: '#607d8b', canAttackAir: true }
};

const RARITY_COLORS = { "Ğ¼Ğ¸Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹": "#f44336", "ÑĞ¿Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹": "#e040fb", "Ñ€ĞµĞ´ĞºĞ¸Ğ¹": "#2196F3", "Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹": "#ffffff" };

const elixirRow = document.getElementById('elixir-row');
for(let i=0; i<10; i++) {
Â  Â  const cell = document.createElement('div');
Â  Â  cell.className = 'elixir-cell';
Â  Â  const fill = document.createElement('div');
Â  Â  fill.className = 'elixir-fill-inner';
Â  Â  cell.appendChild(fill);
Â  Â  elixirRow.appendChild(cell);
}

function getCard() {
Â  Â  let activeDeck = JSON.parse(localStorage.getItem('active_deck') || "[]").filter(c => c !== null);
Â  Â  if(activeDeck.length === 0) return null;
Â  Â Â 
Â  Â  // Ğ‘ĞµÑ€ĞµĞ¼ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ñƒ Ğ¸Ğ· ÑĞ¾ÑÑ‚Ğ°Ğ²Ğ°
Â  Â  let data = activeDeck[Math.floor(Math.random() * activeDeck.length)];
Â  Â  let classKey = data.class.toLowerCase();
Â  Â Â 
Â  Â  // Ğ‘ĞµÑ€ĞµĞ¼ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ ÑÑ‚Ğ°Ñ‚Ñ‹ ĞºĞ»Ğ°ÑÑĞ° Ğ¸Ğ· Ñ‚Ğ²Ğ¾ĞµĞ³Ğ¾ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³Ğ° CLASS_STATS
Â  Â  let base = CLASS_STATS[classKey] || CLASS_STATS['Ğ±Ğ»Ğ¸Ğ¶Ğ½Ğ¸Ğº'];
Â  Â Â 
Â  Â  // ĞŸĞ Ğ˜ĞœĞ•ĞĞ¯Ğ•Ğœ ĞœĞĞ”Ğ˜Ğ¤Ğ˜ĞšĞĞ¢ĞĞ Ğ« Ğ Ğ•Ğ”ĞšĞĞ¡Ğ¢Ğ˜
Â  Â  // Ğ•ÑĞ»Ğ¸ Ğ² ĞºĞ°Ñ€Ñ‚Ğµ ÑƒĞ¶Ğµ ĞµÑÑ‚ÑŒ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ğ¹ statMod (Ğ¸Ğ· Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ğ°), Ğ±ĞµÑ€ĞµĞ¼ ĞµĞ³Ğ¾,Â 
Â  Â  // ĞµÑĞ»Ğ¸ Ğ½ĞµÑ‚ â€” Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¿Ğ¾ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ Ñ€ĞµĞ´ĞºĞ¾ÑÑ‚Ğ¸
Â  Â  let mod = data.statMod;Â 
Â  Â  if (!mod) {
Â  Â  Â  Â  if(data.rarity === 'Ğ¼Ğ¸Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹') mod = 1.10;
Â  Â  Â  Â  else if(data.rarity === 'ÑĞ¿Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹') mod = 1.05;
Â  Â  Â  Â  else if(data.rarity === 'Ñ€ĞµĞ´ĞºĞ¸Ğ¹') mod = 1.02;
Â  Â  Â  Â  else mod = 0.95; // Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹
Â  Â  }

Â  Â  // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¸Ñ‚Ğ¾Ğ³Ğ¾Ğ²Ñ‹Ğµ ÑÑ‚Ğ°Ñ‚Ñ‹
Â  Â  let finalHp = Math.round(base.hp * mod);
Â  Â  let finalDamage = Math.round(base.damage * mod);

Â  Â  return {Â 
Â  Â  Â  Â  ...base,Â 
Â  Â  Â  Â  name: data.name,Â 
Â  Â  Â  Â  type: data.class.toUpperCase(),Â 
Â  Â  Â  Â  rarity: data.rarity,Â 
Â  Â  Â  Â  rating: data.rating,Â 
Â  Â  Â  Â  hp: finalHp,Â 
Â  Â  Â  Â  curHp: finalHp,Â 
Â  Â  Â  Â  damage: finalDamage,Â 
Â  Â  Â  Â  cost: base.costÂ 
Â  Â  };
}
function startGame() {
Â  Â  isBuilding = true; document.getElementById('build-ui').style.display = 'flex';
Â  Â  towers = [
Â  Â  Â  Â  { x: BW/2, y: BH-80, hp: 2000, maxHp: 2000, side: 'player', type: 'Ğ‘Ğ°ÑˆĞ½Ñ', range: 140, canAttackAir: true },
Â  Â  Â  Â  { x: BW/2, y: 80, hp: 2000, maxHp: 2000, side: 'enemy', type: 'Ğ‘Ğ°ÑˆĞ½Ñ', range: 140, canAttackAir: true }
Â  Â  ];
Â  Â  for(let i=0; i<7; i++) walls.push({ cx: Math.floor(Math.random()*COLS), cy: 3+Math.floor(Math.random()*3), vertical: Math.random()>0.5, side: 'enemy', hp: 800, maxHp: 800 });
Â  Â  resize(); renderLoop();
}

function startCountdown() {
Â  Â  isBuilding = false; document.getElementById('build-ui').style.display = 'none';
Â  Â  document.getElementById('countdown').style.display = 'flex';
Â  Â  let count = 3;
Â  Â  let timer = setInterval(() => {
Â  Â  Â  Â  count--;
Â  Â  Â  Â  if(count > 0) document.getElementById('countdown').innerText = count;
Â  Â  Â  Â  else if(count === 0) document.getElementById('countdown').innerText = "Ğ“ĞĞ£!";
Â  Â  Â  Â  else { clearInterval(timer); document.getElementById('countdown').style.display = 'none'; gameActive = true; document.getElementById('controls-wrapper').style.display = 'flex'; hand = []; for(let i=0; i<4; i++) { let c = getCard(); if(c) hand.push(c); } renderHand(); }
Â  Â  }, 1000);
}

function checkCollision(x, y, size) {
Â  Â  for (let w of walls) {
Â  Â  Â  Â  if (w.hp <= 0) continue;
Â  Â  Â  Â  let wx = w.cx * cellW, wy = w.cy * cellH, ww = w.vertical ? 12 : cellW, wh = w.vertical ? cellH : 12;
Â  Â  Â  Â  if (x + size > wx && x - size < wx + ww && y + size > wy && y - size < wy + wh) return w;
Â  Â  }
Â  Â  return null;
}

function updateGame() {
Â  Â  if(gameOverTriggered) return;
Â  Â  elixir = Math.min(10, elixir + eRate); enemyElixir = Math.min(10, enemyElixir + eRate);
Â  Â  document.getElementById('elixir-val').innerText = Math.floor(elixir);
Â  Â  document.querySelectorAll('.elixir-fill-inner').forEach((c, i) => { c.style.width = (Math.max(0, Math.min(1, elixir - i)) * 100) + "%"; });

Â  Â  // Ğ‘ĞĞ¢ Ğ ĞĞ‘ĞĞ¢ĞĞ•Ğ¢ Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ•Ğ¡Ğ›Ğ˜ ĞĞ• Ğ Ğ•Ğ–Ğ˜Ğœ Ğ›ĞĞ‘Ğ‘Ğ˜
Â  Â  if(!isLobbyMode && enemyElixir >= 5 && Date.now() - lastEnemySpawn > 3500) {
Â  Â  Â  Â  let keys = Object.keys(CLASS_STATS);
Â  Â  Â  Â  let randKey = keys[Math.floor(Math.random()*keys.length)];
Â  Â  Â  Â  let u = CLASS_STATS[randKey];
Â  Â  Â  Â  spawnUnit({...u, type: randKey.toUpperCase(), name: "Ğ’Ñ€Ğ°Ğ³"}, 50 + Math.random()*(BW-100), 100 + Math.random()*150, 'enemy');
Â  Â  Â  Â  enemyElixir -= u.cost; lastEnemySpawn = Date.now();
Â  Â  }

Â  Â  units = units.filter(u => u.curHp > 0);
Â  Â  [...units, ...towers].forEach(u => {
Â  Â  Â  Â  if(u.speed === 0 && u.type !== 'Ğ‘Ğ°ÑˆĞ½Ñ' && u.type !== 'Ğ¢Ğ£Ğ Ğ•Ğ›Ğ¬') return;
Â  Â  Â  Â  let possibleTargets;
Â  Â  Â  Â  if(u.isHealer) {
Â  Â  Â  Â  Â  Â  possibleTargets = units.filter(e => e.side === u.side && e.curHp < e.hp);
Â  Â  Â  Â  } else if (u.isTank) {
Â  Â  Â  Â  Â  Â  possibleTargets = [...towers.filter(t => t.side !== u.side), ...units.filter(e => e.side !== u.side && e.isBuilding), ...walls.filter(w => w.side !== u.side && w.hp > 0)];
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  possibleTargets = [...units.filter(e => e.side !== u.side), ...towers.filter(t => t.side !== u.side)];
Â  Â  Â  Â  Â  Â  if(!u.canAttackAir) possibleTargets = possibleTargets.filter(t => !t.isAir);
Â  Â  Â  Â  }

Â  Â  Â  Â  let target = possibleTargets.sort((a,b) => {
Â  Â  Â  Â  Â  Â  let ax = a.x !== undefined ? a.x : a.cx*cellW + cellW/2;
Â  Â  Â  Â  Â  Â  let ay = a.y !== undefined ? a.y : a.cy*cellH + cellH/2;
Â  Â  Â  Â  Â  Â  let bx = b.x !== undefined ? b.x : b.cx*cellW + cellW/2;
Â  Â  Â  Â  Â  Â  let by = b.y !== undefined ? b.y : b.cy*cellH + cellH/2;
Â  Â  Â  Â  Â  Â  return Math.hypot(ax-u.x, ay-u.y) - Math.hypot(bx-u.x, by-u.y);
Â  Â  Â  Â  })[0];

Â  Â  Â  Â  if(!target) {
Â  Â  Â  Â  Â  Â  if(u.speed > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  let dir = u.side === 'player' ? -1 : 1;
Â  Â  Â  Â  Â  Â  Â  Â  u.y += u.speed * dir;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  let tx = target.x !== undefined ? target.x : target.cx*cellW + cellW/2;
Â  Â  Â  Â  let ty = target.y !== undefined ? target.y : target.cy*cellH + cellH/2;
Â  Â  Â  Â  let d = Math.hypot(tx-u.x, ty-u.y);

Â  Â  Â  Â  if(u.type === 'Ğ¢Ğ£Ğ Ğ•Ğ›Ğ¬') u.angle = Math.atan2(ty - u.y, tx - u.x);

Â  Â  Â  Â  if(d < (u.range || 50)) {
Â  Â  Â  Â  Â  Â  let cooldown = u.atkSpeed || 1000;
Â  Â  Â  Â  Â  Â  if(Date.now() - (u.lastAtk||0) > cooldown) {
Â  Â  Â  Â  Â  Â  Â  Â  let dmg = u.type === 'Ğ‘Ğ°ÑˆĞ½Ñ' ? 20 : (u.damage || 10);
Â  Â  Â  Â  Â  Â  Â  Â  if(u.isHealer) target.curHp = Math.min(target.hp, target.curHp + 30);
Â  Â  Â  Â  Â  Â  Â  Â  else {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(target.maxHp !== undefined) target.hp -= dmg;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if(target.hp !== undefined && target.cx !== undefined) target.hp -= dmg;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else target.curHp -= dmg;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  u.lastAtk = Date.now();Â 
Â  Â  Â  Â  Â  Â  Â  Â  fx.push({x1:u.x, y1:u.y, x2:tx, y2:ty, t:6, c: u.isHealer ? '#0f0':'#ffeb3b', isHit: !u.isHealer});
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if(u.speed > 0) {
Â  Â  Â  Â  Â  Â  let angle = Math.atan2(ty-u.y, tx-u.x), vx = Math.cos(angle) * u.speed, vy = Math.sin(angle) * u.speed;
Â  Â  Â  Â  Â  Â  if(u.isAir || u.isTank) {
Â  Â  Â  Â  Â  Â  Â  Â  let obs = checkCollision(u.x + vx * 20, u.y + vy * 20, u.size);
Â  Â  Â  Â  Â  Â  Â  Â  if(obs && obs.side !== u.side) { } else { u.x += vx; u.y += vy; }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  let obstacle = checkCollision(u.x + vx * 25, u.y + vy * 25, u.size);
Â  Â  Â  Â  Â  Â  Â  Â  if(obstacle) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let foundPath = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for(let deg = 35; deg <= 95; deg += 30) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let rad = deg * (Math.PI / 180), lX = Math.cos(angle - rad), lY = Math.sin(angle - rad), rX = Math.cos(angle + rad), rY = Math.sin(angle + rad);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(!checkCollision(u.x + lX * 30, u.y + lY * 30, u.size)) { u.x += lX * u.speed * 1.2; u.y += lY * u.speed * 1.2; foundPath = true; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if(!checkCollision(u.x + rX * 30, u.y + rY * 30, u.size)) { u.x += rX * u.speed * 1.2; u.y += rY * u.speed * 1.2; foundPath = true; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(!foundPath) { u.x -= vx * 0.3; u.y -= vy * 0.3; }
Â  Â  Â  Â  Â  Â  Â  Â  } else { u.x += vx; u.y += vy; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  });
Â  Â  if(towers[0].hp <= 0) endGame("ĞŸĞ ĞĞ˜Ğ“Ğ Ğ«Ğ¨"); if(towers[1].hp <= 0) endGame("ĞŸĞĞ‘Ğ•Ğ”Ğ!");
}

function spawnUnit(card, x, y, side) {
Â  Â  if(card.isSwarm) for(let i=0; i<card.count; i++) units.push({...card, x: x+(i*20-30), y: y+(i*15), curHp: card.hp, side, lastAtk:0, angle: 0});
Â  Â  else units.push({...card, x, y, curHp: card.hp, side, lastAtk: 0, angle: 0});
}

function renderLoop() {
Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  const s = scale * dpr;
Â  Â  ctx.strokeStyle = "rgba(255,255,255,0.05)"; ctx.lineWidth = dpr;
Â  Â  for(let i=0; i<=COLS; i++) { ctx.beginPath(); ctx.moveTo(i*cellW*s, 0); ctx.lineTo(i*cellW*s, BH*s); ctx.stroke(); }
Â  Â  for(let j=0; j<=ROWS; j++) { ctx.beginPath(); ctx.moveTo(0, j*cellH*s); ctx.lineTo(BW*s, j*cellH*s); ctx.stroke(); }
Â  Â  ctx.strokeStyle = "rgba(0, 251, 255, 0.3)"; ctx.lineWidth = 2*dpr;
Â  Â  ctx.beginPath(); ctx.moveTo(0, (BH/2)*s); ctx.lineTo(BW*s, (BH/2)*s); ctx.stroke();
Â  Â  walls.forEach(w => { if(w.hp > 0) { ctx.fillStyle = w.side==='player'?"#2196F3":"#F44336"; ctx.fillRect(w.cx*cellW*s, w.cy*cellH*s, (w.vertical?12:cellW)*s, (w.vertical?cellH:12)*s); } });
Â  Â Â 
Â  Â  [...towers, ...units].forEach(obj => {
Â  Â  Â  Â  let hp = obj.maxHp !== undefined ? obj.hp : obj.curHp, mHp = obj.maxHp !== undefined ? obj.maxHp : obj.hp;
Â  Â  Â  Â  if(hp <= 0) return;
Â  Â  Â  Â  let vX = obj.x * s, vY = obj.y * s, floatY = obj.isAir ? Math.sin(Date.now()/200)*5 : 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (obj.type === 'Ğ‘Ğ°ÑˆĞ½Ñ') {
Â  Â  Â  Â  Â  Â  drawTowerAsset(ctx, obj, vX, vY, s);
Â  Â  Â  Â  Â  Â  drawBar(vX, vY - 80*s, hp, mHp, s, obj.type);
Â  Â  Â  Â  } else if (obj.type === 'Ğ¢Ğ£Ğ Ğ•Ğ›Ğ¬') {
Â  Â  Â  Â  Â  Â  ctx.fillStyle = "#333"; ctx.beginPath(); ctx.arc(vX, vY, obj.size * s, 0, 7); ctx.fill();
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = obj.side === 'player' ? "#00fbff" : "#F44336"; ctx.lineWidth = 2 * dpr; ctx.stroke();
Â  Â  Â  Â  Â  Â  ctx.save(); ctx.translate(vX, vY); ctx.rotate(obj.angle || 0); ctx.fillStyle = "#888"; ctx.fillRect(0, -5 * s, 30 * s, 10 * s); ctx.fillStyle = "#555"; ctx.beginPath(); ctx.arc(0, 0, (obj.size * 0.6) * s, 0, 7); ctx.fill(); ctx.restore();
Â  Â  Â  Â  Â  Â  drawBar(vX, vY - (obj.size + 15) * s, hp, mHp, s, "Ğ¢Ğ£Ğ Ğ•Ğ›Ğ¬");
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  ctx.fillStyle = obj.side === 'enemy' ? '#F44336' : (obj.color || '#00fbff'); ctx.beginPath(); ctx.arc(vX, vY + floatY*s, obj.size*s, 0, 7); ctx.fill();
Â  Â  Â  Â  Â  Â  drawBar(vX, vY - obj.size*s - 15*s, hp, mHp, s, obj.name);
Â  Â  Â  Â  }
Â  Â  });
Â  Â Â 
Â  Â  fx = fx.filter(f => f.t > 0);
Â  Â  fx.forEach(f => {
Â  Â  Â  Â  if(f.isHit) { ctx.beginPath(); ctx.arc(f.x2 * s, f.y2 * s, (15 - f.t) * 1.5 * s, 0, 7); ctx.fillStyle = `rgba(255, 150, 0, ${f.t / 6})`; ctx.fill(); }
Â  Â  Â  Â  ctx.strokeStyle = f.c; ctx.lineWidth = 2*dpr; ctx.beginPath(); ctx.moveTo(f.x1*s, f.y1*s); ctx.lineTo(f.x2*s, f.y2*s); ctx.stroke(); f.t--;
Â  Â  });
Â  Â  if(gameActive) updateGame();
Â  Â  requestAnimationFrame(renderLoop);
}

function drawBar(x, y, val, max, s, name) {Â 
Â  Â  let w = 45 * dpr * scale; ctx.fillStyle = "#000"; ctx.fillRect(x-w/2, y, w, 5*dpr);Â 
Â  Â  ctx.fillStyle = "#4CAF50"; ctx.fillRect(x-w/2, y, Math.max(0, w*(val/max)), 5*dpr);
Â  Â  ctx.fillStyle = "white"; ctx.font = `bold ${9*dpr}px Arial`; ctx.textAlign="center"; ctx.fillText(name, x, y - 4*dpr);
}

function resize() {Â 
Â  Â  scale = Math.min(window.innerWidth / BW, (window.innerHeight - 220) / BH);
Â  Â  canvas.width = BW * scale * dpr; canvas.height = BH * scale * dpr;
Â  Â  canvas.style.width = (BW * scale) + "px"; canvas.style.height = (BH * scale) + "px";
}

function getCanvasCoords(e) { const r = canvas.getBoundingClientRect(); return { x: ((e.touches?e.touches[0].clientX:e.clientX)-r.left)/scale, y: ((e.touches?e.touches[0].clientY:e.clientY)-r.top)/scale }; }

window.onpointerdown = (e) => {Â 
Â  Â  const p = getCanvasCoords(e); lastTouchPos = { x: p.x, y: p.y, active: true };Â 
Â  Â  if(isBuilding) { let f = walls.findIndex(w => p.x > w.cx*cellW && p.x < (w.cx+1)*cellW && p.y > w.cy*cellH && p.y < (w.cy+1)*cellH); if(f !== -1 && walls[f].side==='player') draggingWallIdx = f; }
};
window.onpointermove = (e) => { if(lastTouchPos.active) { let p = getCanvasCoords(e); lastTouchPos.x = p.x; lastTouchPos.y = p.y; } };
window.onpointerup = (e) => {
Â  Â  let p = getCanvasCoords(e);
Â  Â  if(draggingCardIdx !== null) {
Â  Â  Â  Â  let c = hand[draggingCardIdx];
Â  Â  Â  Â  let canPlace = (p.y > BH/2 && p.y <= BH && p.x >=0 && p.x <= BW);
Â  Â  Â  Â  if(canPlace && elixir >= c.cost) {
Â  Â  Â  Â  Â  Â  spawnUnit(c, p.x, p.y, 'player');
Â  Â  Â  Â  Â  Â  // ĞĞ¢ĞŸĞ ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ¡ĞŸĞĞ’Ğ Ğ”Ğ Ğ£Ğ“Ğ£
Â  Â  Â  Â  Â  Â  if(isLobbyMode && conn) conn.send({type:'spawn', key: c.type, x: p.x, y: p.y});
Â  Â  Â  Â  Â  Â  elixir -= c.cost;Â 
Â  Â  Â  Â  Â  Â  let nextCard = getCard();
Â  Â  Â  Â  Â  Â  if(nextCard) hand[draggingCardIdx] = nextCard;
Â  Â  Â  Â  Â  Â  renderHand();
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if(draggingWallIdx !== null) { if(p.x >=0 && p.x <= BW && p.y > BH/2 + 20 && p.y <= BH) { walls[draggingWallIdx].cx = Math.floor(p.x/cellW); walls[draggingWallIdx].cy = Math.floor(p.y/cellH); } draggingWallIdx = null; }
Â  Â  if(fromDock && p.y > BH/2 && wallsLeft > 0) { walls.push({ cx: Math.floor(p.x/cellW), cy: Math.floor(p.y/cellH), vertical: wallRotated, side: 'player', hp: 800, maxHp: 800 }); wallsLeft--; document.getElementById('wall-rem').innerText = wallsLeft; }
Â  Â  draggingCardIdx = null; fromDock = false; lastTouchPos.active = false;
};

setInterval(() => { if(!gameActive) return; battleTime--; if(battleTime <= 0) endGame("ĞĞ˜Ğ§Ğ¬Ğ¯"); let m = Math.floor(battleTime/60), s = battleTime%60; document.getElementById('top-bar').innerText = `${m}:${s<10?'0'+s:s}`; }, 1000);
function handleRotate() { wallRotated = !wallRotated; }
function startWallDrag() { fromDock = true; lastTouchPos.active = true; }
function randomPlayerWalls() { deleteAllWalls(); while(wallsLeft > 0) { walls.push({ cx: Math.floor(Math.random()*COLS), cy: 11+Math.floor(Math.random()*3), vertical: Math.random()>0.5, side: 'player', hp: 800, maxHp: 800 }); wallsLeft--; } document.getElementById('wall-rem').innerText = 0; }
function deleteAllWalls() { walls = walls.filter(w => w.side !== 'player'); wallsLeft = 7; document.getElementById('wall-rem').innerText = 7; }
function confirmReady() { startCountdown(); }

function renderHand() {Â 
Â  Â  let h = document.getElementById('hand-container'); h.innerHTML = '';
Â  Â  hand.forEach((c, i) => {
Â  Â  Â  Â  let rColor = RARITY_COLORS[c.rarity] || "#fff";
Â  Â  Â  Â  let d = document.createElement('div'); d.className = 'card';Â 
Â  Â  Â  Â  d.style.borderColor = rColor;
Â  Â  Â  Â  d.style.boxShadow = `0 0 10px ${rColor}44`;
Â  Â  Â  Â  d.innerHTML = `<div id="overlay-${i}" class="card-overlay"></div><div class="cost">${c.cost}</div><div class="rating-tag" style="color:${rColor}">${c.rating}</div><b style="color:${c.color}">${c.name}</b><small style="font-size:7px; opacity:0.7">${c.type}</small>`;
Â  Â  Â  Â  d.onpointerdown = (e) => { e.stopPropagation(); if(elixir >= c.cost) draggingCardIdx = i; lastTouchPos.active = true; }; h.appendChild(d);
Â  Â  });
}

function endGame(m) {Â 
Â  Â  gameOverTriggered = true; gameActive = false;Â 
Â  Â  document.getElementById('game-msg-box').style.display = 'flex';Â 
Â  Â  document.getElementById('game-msg-text').innerText = m;Â 
Â  Â  let currentCoins = parseInt(localStorage.getItem('it_coins') || 0);
Â  Â  if(m === "ĞŸĞĞ‘Ğ•Ğ”Ğ!") currentCoins += 100;
Â  Â  else if(m === "ĞĞ˜Ğ§Ğ¬Ğ¯") currentCoins += 50;
Â  Â  localStorage.setItem('it_coins', currentCoins);
}

window.onresize = resize;Â 
resize();
</script>
</body>
</html>